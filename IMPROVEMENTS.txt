=============================================================================
                         EMOJI BOT IMPROVEMENTS
=============================================================================

=============================================================================
DEALING WITH DDOS ATTACKS / SPAM PROTECTION
=============================================================================

1. RATE LIMITING (Currently Implemented - Basic)
   ---------------------------------------------
   Location: middlewares/throttling.py
   Current: 3 messages/sec, 5 callbacks/sec

   Improvements needed:
   - Add per-user rate limits for processing requests
   - Implement sliding window rate limiting
   - Add exponential backoff for repeat offenders

2. PROCESSING QUEUE WITH LIMITS
   -----------------------------
   Implement a queue system:
   - Max 1 concurrent processing task per user
   - Max 5 processing requests per user per hour
   - Max 20 processing requests per user per day

   Example implementation:
   ```python
   from collections import defaultdict
   from datetime import datetime, timedelta

   user_processing_count = defaultdict(list)

   def can_process(user_id: int, hourly_limit: int = 5, daily_limit: int = 20) -> bool:
       now = datetime.now()
       hour_ago = now - timedelta(hours=1)
       day_ago = now - timedelta(days=1)

       # Clean old entries
       user_processing_count[user_id] = [
           t for t in user_processing_count[user_id] if t > day_ago
       ]

       hourly = sum(1 for t in user_processing_count[user_id] if t > hour_ago)
       daily = len(user_processing_count[user_id])

       return hourly < hourly_limit and daily < daily_limit
   ```

3. USER COOLDOWN SYSTEM
   ---------------------
   Add cooldown between processing requests:
   - 30 seconds cooldown between image processing
   - 60 seconds cooldown between video processing
   - Show remaining cooldown time to user

   Store in database or Redis:
   ```python
   user_last_process = {}
   COOLDOWN_IMAGE = 30  # seconds
   COOLDOWN_VIDEO = 60  # seconds
   ```

4. BLACKLIST/BAN SYSTEM
   ---------------------
   Add to database:
   ```sql
   CREATE TABLE banned_users (
       user_id INTEGER PRIMARY KEY,
       banned_at TIMESTAMP,
       reason TEXT,
       banned_until TIMESTAMP  -- NULL for permanent
   );
   ```

   Auto-ban triggers:
   - More than 50 requests in 1 hour = 1 hour ban
   - More than 100 requests in 1 day = 24 hour ban
   - Repeated violations = permanent ban

   Admin commands:
   - /ban <user_id> [duration] [reason]
   - /unban <user_id>
   - /banned - list banned users

5. CAPTCHA FOR SUSPICIOUS ACTIVITY
   --------------------------------
   If user exceeds soft limits, require captcha:
   - Simple math question: "What is 5 + 3?"
   - Image-based captcha
   - Timeout if not solved in 60 seconds

6. FILE SIZE AND COMPLEXITY LIMITS
   --------------------------------
   Already implemented:
   - Max file size: 50MB
   - Max video duration: 300 seconds

   Additional limits to add:
   - Max grid size based on user reputation
   - New users: max 4x4 grid
   - Trusted users (>10 successful packs): max 8x8 grid

7. RESOURCE MONITORING
   --------------------
   Monitor and limit based on server resources:
   - CPU usage threshold (pause new tasks if >80%)
   - Memory usage threshold
   - Disk space for cache

   ```python
   import psutil

   def server_can_process() -> bool:
       cpu = psutil.cpu_percent()
       memory = psutil.virtual_memory().percent
       return cpu < 80 and memory < 85
   ```

8. TELEGRAM'S BUILT-IN PROTECTION
   -------------------------------
   Telegram already provides some protection:
   - Bot API rate limits
   - Flood control (error 429)

   Handle these gracefully:
   ```python
   from aiogram.exceptions import TelegramRetryAfter

   try:
       await bot.send_message(...)
   except TelegramRetryAfter as e:
       await asyncio.sleep(e.retry_after)
       # retry
   ```

9. PRIORITY QUEUE SYSTEM
   ----------------------
   Implement user tiers:
   - Free users: low priority, strict limits
   - Premium users: high priority, relaxed limits
   - Admin: highest priority, no limits

   Queue processing order based on priority.

10. LOGGING AND ALERTING
    ---------------------
    Log suspicious activity:
    - Rapid consecutive requests
    - Failed processing attempts
    - Unusual patterns

    Send alerts to admin:
    - Telegram notification when limits exceeded
    - Daily summary of suspicious users


=============================================================================
QUICK IMPLEMENTATION PRIORITY
=============================================================================

HIGH PRIORITY (Implement First):
1. Per-user processing limits (hourly/daily)
2. Cooldown between requests
3. Auto-ban for excessive usage

MEDIUM PRIORITY:
4. Blacklist system with admin commands
5. Resource monitoring
6. Logging and alerting

LOW PRIORITY (Nice to Have):
7. Captcha system
8. Priority queue
9. User reputation system


=============================================================================
EXAMPLE: SIMPLE ANTI-SPAM MIDDLEWARE
=============================================================================

```python
# middlewares/antispam.py

from aiogram import BaseMiddleware
from aiogram.types import Message
from datetime import datetime, timedelta
from collections import defaultdict

class AntiSpamMiddleware(BaseMiddleware):
    def __init__(self, max_requests: int = 10, period: int = 60):
        self.max_requests = max_requests
        self.period = period
        self.user_requests = defaultdict(list)

    async def __call__(self, handler, event: Message, data: dict):
        user_id = event.from_user.id
        now = datetime.now()
        cutoff = now - timedelta(seconds=self.period)

        # Clean old requests
        self.user_requests[user_id] = [
            t for t in self.user_requests[user_id] if t > cutoff
        ]

        # Check limit
        if len(self.user_requests[user_id]) >= self.max_requests:
            await event.answer(
                f"⚠️ Too many requests. Please wait {self.period} seconds."
            )
            return

        # Record this request
        self.user_requests[user_id].append(now)

        return await handler(event, data)
```

Usage in main.py:
```python
from middlewares.antispam import AntiSpamMiddleware

dp.message.middleware(AntiSpamMiddleware(max_requests=10, period=60))
```


=============================================================================
